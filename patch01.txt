+ 1
// Modified for 4MMAOD
+ 999
 * Local data used by the "longest match" routines.
+ 999
 */
+ 999

+ 999
typedef ush Pos;
+ 999
typedef unsigned IPos;
+ 999
/* A Pos is an index in the character window. We use short instead of int to
+ 999
 * save space in the various tables. IPos is used only for parameter passing.
+ 999
 */
+ 999

+ 999
/* DECLARE(uch, window, 2L*WSIZE); */
+ 999
/* Sliding window. Input bytes are read into the second half of the window,
+ 999
 * and move to the first half later to keep a dictionary of at least WSIZE
+ 999
 * bytes. With this organization, matches are limited to a distance of
+ 999
 * WSIZE-MAX_MATCH bytes, but this ensures that IO is always
+ 999
 * performed with a length multiple of the block size. Also, it limits
+ 999
 * the window size to 64K, which is quite useful on MSDOS.
+ 999
 * To do: limit the window size to WSIZE+BSZ if SMALL_MEM (the code would
+ 999
 * be less efficient).
+ 999
 */
+ 999

+ 999
/* DECLARE(Pos, prev, WSIZE); */
+ 999
/* Link to older string with same hash index. To limit the size of this
+ 999
 * array to 64K, this link is maintained only for the last 32K strings.
+ 999
 * An index in this array is thus a window index modulo 32K.
+ 999
 */
+ 999

+ 999
/* DECLARE(Pos, head, 1<<HASH_BITS); */
+ 999
/* Heads of the hash chains or NIL. */
+ 999

+ 999
ulg window_size = (ulg)2*WSIZE;
+ 999
/* window size, 2*WSIZE except for MMAP or BIG_MEM, where it is the
+ 999
 * input file length plus MIN_LOOKAHEAD.
+ 999
 */
+ 999

+ 999
long block_start;
+ 999
/* window position at the beginning of the current output block. Gets
+ 999
 * negative when the window is moved backwards.
+ 999
 */
+ 999

+ 999
local unsigned ins_h;  /* hash index of string to be inserted */
+ 999

+ 999
#define H_SHIFT  ((HASH_BITS+MIN_MATCH-1)/MIN_MATCH)
+ 999
/* Number of bits by which ins_h and del_h must be shifted at each
+ 999
 * input step. It must be such that after MIN_MATCH steps, the oldest
+ 999
 * byte no longer takes part in the hash key, that is:
+ 999
 *   H_SHIFT * MIN_MATCH >= HASH_BITS
+ 999
 */
+ 999

+ 999
unsigned int near prev_length;
+ 999
/* Length of the best match at previous step. Matches not greater than this
+ 999
 * are discarded. This is used in the lazy match evaluation.
+ 999
 */
+ 999

+ 999
      unsigned near strstart;      /* start of string to insert */
+ 999
      unsigned near match_start;   /* start of matching string */
+ 999
local int           eofile;        /* flag set at end of input file */
+ 999
local unsigned      lookahead;     /* number of valid bytes ahead in window */
+ 999

+ 999
unsigned near max_chain_length;
+ 999
/* To speed up deflation, hash chains are never searched beyond this length.
+ 999
 * A higher limit improves compression ratio but degrades the speed.
+ 999
 */
+ 999

+ 999
local unsigned int max_lazy_match;
+ 999
/* Attempt to find a better match only when the current match is strictly
+ 999
 * smaller than this value. This mechanism is used only for compression
+ 999
 * levels >= 4.
+ 999
 */
+ 999
#define max_insert_length  max_lazy_match
+ 999
/* Insert new strings in the hash table only if the match length
+ 999
 * is not greater than this length. This saves time but degrades compression.
+ 999
 * max_insert_length is used only for compression levels <= 3.
+ 999
 */
+ 999

+ 999
local int compr_level;
+ 999
/* compression level (1..9) */
+ 999

+ 999
unsigned near good_match;
+ 999
/* Use a faster search when the previous match is longer than this */
+ 999

+ 999
local ulg rsync_sum;  /* rolling sum of rsync window */
+ 999
local ulg rsync_chunk_end; /* next rsync sequence point */
+ 999

+ 999
/* Values for max_lazy_match, good_match and max_chain_length, depending on
+ 999
 * the desired pack level (0..9). The values given below have been tuned to
+ 999
 * exclude worst case performance for pathological files. Better values may be
+ 999
 * found for specific files.
+ 999
 */
+ 999

+ 999
typedef struct config {
+ 999
   ush good_length; /* reduce lazy search above this match length */
+ 999
   ush max_lazy;    /* do not perform lazy search above this match length */
+ 999
   ush nice_length; /* quit search above this match length */
+ 999
   ush max_chain;
+ 999
} config;
+ 999

+ 999
#ifdef  FULL_SEARCH
+ 999
# define nice_match MAX_MATCH
+ 999
#else
+ 999
  int near nice_match; /* Stop searching when current match exceeds this */
+ 999
#endif
+ 999

+ 999
local config configuration_table[10] = {
+ 999
/*      good lazy nice chain */
+ 999
/* 0 */ {0,    0,  0,    0},  /* store only */
+ 999
/* 1 */ {4,    4,  8,    4},  /* maximum speed, no lazy matches */
+ 999
/* 2 */ {4,    5, 16,    8},
+ 999
/* 3 */ {4,    6, 32,   32},
+ 999

+ 999
/* 4 */ {4,    4, 16,   16},  /* lazy matches */
+ 999
/* 5 */ {8,   16, 32,   32},
+ 999
/* 6 */ {8,   16, 128, 128},
+ 999
/* 7 */ {8,   32, 128, 256},
+ 999
/* 8 */ {32, 128, 258, 1024},
+ 999
/* 9 */ {32, 258, 258, 4096}}; /* maximum compression */
+ 999

+ 999
/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
+ 999
 * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
+ 999
 * meaning.
+ 999
 */
+ 999

+ 999
#define EQUAL 0
+ 999
/* result of memcmp for equal strings */
+ 999

+ 999
/* ===========================================================================
+ 999
 *  Prototypes for local functions.
+ 999
 */
+ 999
local void fill_window   OF((void));
+ 999
local off_t deflate_fast OF((void));
+ 999

+ 999
      int  longest_match OF((IPos cur_match));
+ 999
#ifdef ASMV
+ 999
      void match_init OF((void)); /* asm code initialization */
+ 999
#endif
+ 999

+ 999
#ifdef DEBUG
+ 999
local  void check_match OF((IPos start, IPos match, int length));
+ 999
#endif
+ 999

+ 999
/* ===========================================================================
+ 999
 * Update a hash value with the given input byte
+ 999
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
+ 999
 *    input characters, so that a running hash key can be computed from the
+ 999
 *    previous key instead of complete recalculation each time.
+ 999
 */
+ 999
#define UPDATE_HASH(h,c) (h = (((h)<<H_SHIFT) ^ (c)) & HASH_MASK)
+ 999

+ 999
/* ===========================================================================
+ 999
 * Insert string s in the dictionary and set match_head to the previous head
+ 999
 * of the hash chain (the most recent string with same hash key). Return
+ 999
 * the previous length of the hash chain.
+ 999
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
+ 999
 *    input characters and the first MIN_MATCH bytes of s are valid
+ 999
 *    (except for the last MIN_MATCH-1 bytes of the input file).
+ 999
 */
+ 999
#define INSERT_STRING(s, match_head) \
+ 999
   (UPDATE_HASH(ins_h, window[(s) + MIN_MATCH-1]), \
+ 999
    prev[(s) & WMASK] = match_head = head[ins_h], \
+ 999
    head[ins_h] = (s))
+ 999

+ 999
/* ===========================================================================
+ 999
 * Initialize the "longest match" routines for a new file
+ 999
 */
+ 999
void lm_init (pack_level, flags)
+ 999
    int pack_level; /* 0: store, 1: best speed, 9: best compression */
+ 999
    ush *flags;     /* general purpose bit flag */
+ 999
{
+ 999
    register unsigned j;
+ 999

+ 999
    if (pack_level < 1 || pack_level > 9) error("bad pack level");
+ 999
    compr_level = pack_level;
+ 999

+ 999
    /* Initialize the hash table. */
+ 999
#if defined(MAXSEG_64K) && HASH_BITS == 15
+ 999
    for (j = 0;  j < HASH_SIZE; j++) head[j] = NIL;
+ 999
#else
+ 999
    memzero((char*)head, HASH_SIZE*sizeof(*head));
+ 999
#endif
+ 999
    /* prev will be initialized on the fly */
+ 999

+ 999
    /* rsync params */
+ 999
    rsync_chunk_end = 0xFFFFFFFFUL;
+ 999
    rsync_sum = 0;
+ 999

+ 999
    /* Set the default configuration parameters:
+ 999
     */
+ 999
    max_lazy_match   = configuration_table[pack_level].max_lazy;
+ 999
    good_match       = configuration_table[pack_level].good_length;
+ 999
#ifndef FULL_SEARCH
+ 999
    nice_match       = configuration_table[pack_level].nice_length;
+ 999
#endif
+ 999
    max_chain_length = configuration_table[pack_level].max_chain;
+ 999
    if (pack_level == 1) {
+ 999
       *flags |= FAST;
+ 999
    } else if (pack_level == 9) {
+ 999
       *flags |= SLOW;
+ 999
    }
+ 999
    /* ??? reduce max_chain_length for binary files */
